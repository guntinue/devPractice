# algorithm-practice

---

## 에라토스테네스의 체(Sieve of Eratosthenes)
> 특정 범위 내에서 쉽게 소수 판정

소수(prime number): 1과 자기 자신의 반수로 밖에 나누어 떨어지지 않는 1 이외의 정수, **즉 양의 약수가 2개인 자연수 혹은 정수**
-막무가내로 정수 N에서 소수인지 판별하려고 하면 N개의 수에서 2의 배수 빼고 3의 배수 빼고 ...이런 방식을 반복할 것이다.
하지만 **에라토스테네스의 체**를 활용하면 이런 방식을 사용하지 않는다.

만약 n보다 작은 어떤 수 m이 m=ab라면 a와 b중 적어도 하나는 √n이하이다. **즉 n보다 작은 합 성수 m은 √n보다 작은 수의 배수만 체크해도 전부 지워진다는 의미!!**

### 하지만 이것은 특정 범위 내의 소수를 만정하는 데에만 효율적임!! 

---

## 유클리드 호제법(Euclidean algorithm)
>두 양의 정수 혹은 두 다항식의 최대공약수 구하기

두 양의 정수 a,b(a>b)에 대하여 a=bq+r(0<=r<b)이라 하면 a,b의 최대공약수는 b,r의 최대공약수와 같다.
**즉, gcd(a,b)=gcd(b,r)** 여기서 만약 r=0이면 a,b의 최대공약수는 b가 된다.

*참고로 두 정수 a,b의 최소공배수는  a * b / 최대공약수*

보통은 나머지가 0이 될때까지 연속해서 사용한다.

ex) 2484와 4212의 최대 공약수 구하기
```
4212=2484 * 1 + 1728
2484=1728 * 1 + 756
1728=756 * 2 + 216
756=216 * 3 + 108
216=108 * 2
따라서 두 수의 최대공약수는 108
```

---

## HashMap
> HashMap의 한계

HashMap은 일단 자바에서 키(key)와 값(Value)쌍을 저장하는 자료 구조를 뜻하고 이 키(key)는 고유하고 키를 사용하여 해당하는 값을 빠르게 검색 가능하다

**hashMap의 특징**
1. 키를 기반한 빠른 액세스(시간 복잡도가 O(1)이다)
2. 순서를 보장하지 않는다.(**왜냐면 내부적으로 키의 순서를 보장하지 않는다**)
3. 키의 중복이 불가능하다.(HashMap의 특성상 이미 존재하는 키에 대해 값을 저장하면 기존 값이 덮어씌워진다. 또한 key로 값을 찾는것이므로 같은 키를 갖는 여러 value가 존재할 수 없다.)
4. 키 기반의 유연성 : 어떤 객체든 키로 사용할 수 있다.

<img width="1326" height="784" alt="Image" src="https://github.com/user-attachments/assets/3f11afa9-a033-47d4-a53f-03416308ac20" />

**hashMap의 한계**

1. HashMap은 **버킷 배열**을 기반으로 데이터를 저장, 데이터가 많아지면 같은 인덱스에 여러 값이 연결되어 해시 충돌이 생긴다.

2. HashMap은 **멀티스레드환경**에서 동기화되지 않기 때문에, 동시에 접근하면 내부 구조가 쉽게 망가지므로 **thread-safe하지 않다.**


->이러한 멀티스레드 환경을 효율적으로 지원하기 위해서 **ConcurrentHashMap**을 사용하면 버킷/구역 단위로 lock을 걸어서 서로 다른 키에 대한 작업은 최대한 병렬로 돌게 한다.

---

## Array
>Array vs List

1. Array는 **고정길이**를 갖지만 List는 **동적길이**를 갖는다.
2. 속도는 Array와 ArrayList 둘다 빠르지만 **추가는 List가 월등히 빠르다**

>Array: char[] vs String[]

- char는 **primitive(원시타입)**이지만, String은 **객체(Object)**이기 때문에 메모리 구조와 생성 비용, 비교 방식, 변경 방식 등 **모든 면에서 차이가 난다**

---


  



